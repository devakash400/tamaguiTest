import { PresenceContext, ResetPresence, usePresence } from "@tamagui/use-presence";
import { useMotify } from "moti/author";
import { useContext, useMemo } from "react";
import Animated, { cancelAnimation, runOnJS, useAnimatedReaction, useAnimatedStyle, useDerivedValue, useSharedValue, withSpring, withTiming } from "react-native-reanimated";
const onlyAnimateKeys = {
  transform: !0,
  opacity: !0,
  height: !0,
  width: !0,
  backgroundColor: !0,
  borderColor: !0,
  borderLeftColor: !0,
  borderRightColor: !0,
  borderTopColor: !0,
  borderBottomColor: !0,
  borderRadius: !0,
  borderTopLeftRadius: !0,
  borderTopRightRadius: !0,
  borderBottomLeftRadius: !0,
  borderBottomRightRadius: !0,
  borderLeftWidth: !0,
  borderRightWidth: !0,
  borderTopWidth: !0,
  borderBottomWidth: !0,
  color: !0,
  left: !0,
  right: !0,
  top: !0,
  bottom: !0
};
function createAnimations(animations) {
  return {
    // View: isWeb ? AnimatedView : Animated.View,
    // Text: isWeb ? AnimatedText : Animated.Text,
    View: Animated.View,
    Text: Animated.Text,
    isReactNative: !0,
    animations,
    usePresence,
    ResetPresence,
    useAnimatedNumber(initial) {
      const sharedValue = useSharedValue(initial);
      return useMemo(() => ({
        getInstance() {
          "worklet";

          return sharedValue;
        },
        getValue() {
          "worklet";

          return sharedValue.value;
        },
        setValue(next, config = {
          type: "spring"
        }, onFinish) {
          "worklet";

          config.type === "direct" ? (sharedValue.value = next, onFinish?.()) : config.type === "spring" ? sharedValue.value = withSpring(next, config, onFinish ? () => {
            "worklet";

            runOnJS(onFinish)();
          } : void 0) : sharedValue.value = withTiming(next, config, onFinish ? () => {
            "worklet";

            runOnJS(onFinish)();
          } : void 0);
        },
        stop() {
          "worklet";

          cancelAnimation(sharedValue);
        }
      }), [sharedValue]);
    },
    useAnimatedNumberReaction({
      value
    }, onValue) {
      const instance = value.getInstance();
      return useAnimatedReaction(() => instance.value, (next, prev) => {
        prev !== next && runOnJS(onValue)(next);
      },
      // dependency array is very important here
      [onValue, instance]);
    },
    /**
     * `getStyle` must be a worklet
     */
    useAnimatedNumberStyle(val, getStyle) {
      const instance = val.getInstance(),
        derivedValue = useDerivedValue(() => instance.value, [instance, getStyle]);
      return useAnimatedStyle(() => getStyle(derivedValue.value), [val, getStyle, derivedValue, instance]);
    },
    useAnimations: animationProps => {
      const {
          props,
          presence,
          style,
          onDidAnimate,
          componentState
        } = animationProps,
        animationKey = Array.isArray(props.animation) ? props.animation[0] : props.animation,
        isHydrating = componentState.unmounted === "should-enter";
      let animate = {},
        dontAnimate = {};
      if (isHydrating) dontAnimate = style;else {
        const animateOnly = props.animateOnly;
        for (const key in style) {
          const value = style[key];
          !onlyAnimateKeys[key] || value === "auto" || animateOnly && !animateOnly.includes(key) ? dontAnimate[key] = value : animate[key] = value;
        }
      }
      const animateStr = JSON.stringify(animate),
        styles = useMemo(() => JSON.parse(animateStr), [animateStr]),
        isExiting = !!presence?.[1],
        presenceContext = useContext(PresenceContext),
        usePresenceValue = presence || void 0,
        transition = {
          ...animations[animationKey]
        };
      if (Array.isArray(props.animation)) {
        const config = props.animation[1];
        if (config && typeof config == "object") for (const key in config) {
          const val = config[key];
          typeof val == "string" ? transition[key] = animations[val] : transition[key] = val;
        }
      }
      const motiProps = {
          animate: isExiting || isHydrating ? {} : styles,
          transition,
          usePresenceValue,
          presenceContext,
          exit: isExiting ? styles : void 0
        },
        moti = useMotify(motiProps);
      return process.env.NODE_ENV === "development" && props.debug && console.info("useMotify(", JSON.stringify(motiProps, null, 2) + ")", {
        animationProps,
        motiProps,
        moti,
        style: [dontAnimate, moti.style]
      }), {
        style: [dontAnimate, moti.style]
      };
    }
  };
}
export { createAnimations };