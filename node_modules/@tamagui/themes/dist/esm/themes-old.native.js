import { addChildren, applyMask, createStrengthenMask, createTheme, createWeakenMask, skipMask } from "@tamagui/create-theme";
import { colorTokens, darkColors, lightColors } from "./tokens";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array(arr);
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys2 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _array_like_to_array(o, minLen);
  }
}
var lightTransparent = "rgba(255,255,255,0)", darkTransparent = "rgba(10,10,10,0)", palettes = {
  dark: [
    darkTransparent,
    "#050505",
    "#151515",
    "#191919",
    "#232323",
    "#282828",
    "#323232",
    "#424242",
    "#494949",
    "#545454",
    "#626262",
    "#a5a5a5",
    "#fff",
    lightTransparent
  ],
  light: [
    lightTransparent,
    "#fff",
    "#f9f9f9",
    "hsl(0, 0%, 97.3%)",
    "hsl(0, 0%, 95.1%)",
    "hsl(0, 0%, 94.0%)",
    "hsl(0, 0%, 92.0%)",
    "hsl(0, 0%, 89.5%)",
    "hsl(0, 0%, 81.0%)",
    "hsl(0, 0%, 56.1%)",
    "hsl(0, 0%, 50.3%)",
    "hsl(0, 0%, 42.5%)",
    "hsl(0, 0%, 9.0%)",
    darkTransparent
  ]
}, templateColors = {
  color1: 1,
  color2: 2,
  color3: 3,
  color4: 4,
  color5: 5,
  color6: 6,
  color7: 7,
  color8: 8,
  color9: 9,
  color10: 10,
  color11: 11,
  color12: 12
}, templateShadows = {
  shadowColor: 1,
  shadowColorHover: 1,
  shadowColorPress: 2,
  shadowColorFocus: 2
}, toSkip = _object_spread({}, templateShadows), override = Object.fromEntries(Object.entries(toSkip).map(function(param) {
  var _param = _sliced_to_array(param, 1), k = _param[0];
  return [
    k,
    0
  ];
})), overrideShadows = Object.fromEntries(Object.entries(templateShadows).map(function(param) {
  var _param = _sliced_to_array(param, 1), k = _param[0];
  return [
    k,
    0
  ];
})), overrideWithColors = _object_spread_props(_object_spread({}, override), {
  color: 0,
  colorHover: 0,
  colorFocus: 0,
  colorPress: 0
}), template = _object_spread_props(_object_spread({}, templateColors, toSkip), {
  // the background, color, etc keys here work like generics - they make it so you
  // can publish components for others to use without mandating a specific color scale
  // the @tamagui/button Button component looks for `$background`, so you set the
  // dark_red_Button theme to have a stronger background than the dark_red theme.
  background: 2,
  backgroundHover: 3,
  backgroundPress: 4,
  backgroundFocus: 5,
  backgroundStrong: 1,
  backgroundTransparent: 0,
  color: -1,
  colorHover: -2,
  colorPress: -1,
  colorFocus: -2,
  colorTransparent: -0,
  borderColor: 4,
  borderColorHover: 5,
  borderColorPress: 3,
  borderColorFocus: 4,
  placeholderColor: -4
}), lightShadowColor = "rgba(0,0,0,0.02)", lightShadowColorStrong = "rgba(0,0,0,0.066)", darkShadowColor = "rgba(0,0,0,0.2)", darkShadowColorStrong = "rgba(0,0,0,0.3)", lightShadows = {
  shadowColor: lightShadowColorStrong,
  shadowColorHover: lightShadowColorStrong,
  shadowColorPress: lightShadowColor,
  shadowColorFocus: lightShadowColor
}, darkShadows = {
  shadowColor: darkShadowColorStrong,
  shadowColorHover: darkShadowColorStrong,
  shadowColorPress: darkShadowColor,
  shadowColorFocus: darkShadowColor
}, lightTemplate = _object_spread(_object_spread_props(_object_spread({}, template), {
  background: 2,
  backgroundHover: 3,
  backgroundPress: 4,
  // our light color palette is... a bit unique
  borderColor: 6,
  borderColorHover: 7,
  borderColorFocus: 5,
  borderColorPress: 6
}), lightShadows), darkTemplate = _object_spread({}, template, darkShadows), light = createTheme(palettes.light, lightTemplate), dark = createTheme(palettes.dark, darkTemplate), baseThemes = {
  light,
  dark
}, masks = {
  skip: skipMask,
  weaker: createWeakenMask(),
  stronger: createStrengthenMask()
}, maskOptions = {
  override,
  skip: toSkip,
  // avoids the transparent ends
  max: palettes.light.length - 2,
  min: 1
}, transparent = function(hsl) {
  var opacity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return hsl.replace("%)", "%, ".concat(opacity, ")")).replace("hsl(", "hsla(");
}, _map = _sliced_to_array([
  colorTokens.light,
  colorTokens.dark
].map(function(colorSet, i) {
  var isLight = i === 0, theme = baseThemes[isLight ? "light" : "dark"];
  return Object.fromEntries(Object.keys(colorSet).map(function(color) {
    var colorPalette = Object.values(colorSet[color]), _ref = [
      colorPalette.slice(0, 6),
      colorPalette.slice(colorPalette.length - 5)
    ], head = _ref[0], tail = _ref[1], palette = [
      transparent(colorPalette[0])
    ].concat(_to_consumable_array(head), _to_consumable_array(tail), [
      theme.color,
      transparent(colorPalette[colorPalette.length - 1])
    ]), colorTheme = createTheme(palette, isLight ? _object_spread_props(_object_spread({}, lightTemplate), {
      // light color themes are a bit less sensitive
      borderColor: 4,
      borderColorHover: 5,
      borderColorFocus: 4,
      borderColorPress: 4
    }) : darkTemplate);
    return [
      color,
      colorTheme
    ];
  }));
}), 2), lightColorThemes = _map[0], darkColorThemes = _map[1], allThemes = addChildren(baseThemes, function(name, theme) {
  var isLight = name === "light", inverseName = isLight ? "dark" : "light", inverseTheme = baseThemes[inverseName], colorThemes = isLight ? lightColorThemes : darkColorThemes, inverseColorThemes = isLight ? darkColorThemes : lightColorThemes, allColorThemes = addChildren(colorThemes, function(colorName, colorTheme) {
    var inverse = inverseColorThemes[colorName];
    return _object_spread({}, getAltThemes({
      theme: colorTheme,
      inverse,
      isLight
    }), getComponentThemes(colorTheme, inverse, isLight));
  }), baseSubThemes = _object_spread({}, getAltThemes({
    theme,
    inverse: inverseTheme,
    isLight
  }), getComponentThemes(theme, inverseTheme, isLight));
  return _object_spread({}, baseSubThemes, allColorThemes);
});
function getAltThemes(param) {
  var theme = param.theme, inverse = param.inverse, isLight = param.isLight, activeTheme = param.activeTheme, maskOptionsAlt = _object_spread_props(_object_spread({}, maskOptions), {
    override: overrideShadows
  }), alt1 = applyMask(theme, masks.weaker, maskOptionsAlt), alt2 = applyMask(alt1, masks.weaker, maskOptionsAlt), active = activeTheme ?? (process.env.ACTIVE_THEME_INVERSE ? inverse : function() {
    return applyMask(theme, masks.weaker, _object_spread_props(_object_spread({}, maskOptions), {
      strength: 3,
      skip: _object_spread_props(_object_spread({}, maskOptions.skip), {
        color: 1
      })
    }));
  }());
  return addChildren({
    alt1,
    alt2,
    active
  }, function(_, subTheme) {
    return getComponentThemes(subTheme, subTheme === inverse ? theme : inverse, isLight);
  });
}
function getComponentThemes(theme, inverse, isLight) {
  var componentMaskOptions = _object_spread_props(_object_spread({}, maskOptions), {
    override: overrideWithColors,
    skip: _object_spread(
      {},
      maskOptions.skip,
      // skip colors too just for component sub themes
      templateColors
    )
  }), weaker1 = applyMask(theme, masks.weaker, componentMaskOptions), base = applyMask(weaker1, masks.stronger, componentMaskOptions), weaker2 = applyMask(weaker1, masks.weaker, componentMaskOptions), stronger1 = applyMask(theme, masks.stronger, componentMaskOptions), inverse1 = applyMask(inverse, masks.weaker, componentMaskOptions), inverse2 = applyMask(inverse1, masks.weaker, componentMaskOptions), strongerBorderLighterBackground = isLight ? _object_spread_props(_object_spread({}, stronger1), {
    borderColor: weaker1.borderColor,
    borderColorHover: weaker1.borderColorHover,
    borderColorPress: weaker1.borderColorPress,
    borderColorFocus: weaker1.borderColorFocus
  }) : _object_spread_props(_object_spread({}, applyMask(theme, masks.skip, componentMaskOptions)), {
    borderColor: weaker1.borderColor,
    borderColorHover: weaker1.borderColorHover,
    borderColorPress: weaker1.borderColorPress,
    borderColorFocus: weaker1.borderColorFocus
  }), overlayTheme = {
    background: isLight ? "rgba(0,0,0,0.5)" : "rgba(0,0,0,0.9)"
  }, weaker2WithoutBorder = _object_spread_props(_object_spread({}, weaker2), {
    borderColor: "transparent",
    borderColorHover: "transparent"
  });
  return {
    ListItem: isLight ? stronger1 : base,
    Card: weaker1,
    Button: weaker2WithoutBorder,
    Checkbox: weaker2,
    DrawerFrame: weaker1,
    SliderTrack: stronger1,
    SliderTrackActive: weaker2,
    SliderThumb: inverse1,
    Progress: weaker1,
    ProgressIndicator: inverse,
    Switch: weaker2,
    SwitchThumb: inverse2,
    TooltipArrow: weaker1,
    TooltipContent: weaker2,
    Input: strongerBorderLighterBackground,
    TextArea: strongerBorderLighterBackground,
    Tooltip: inverse1,
    // make overlays always dark
    SheetOverlay: overlayTheme,
    DialogOverlay: overlayTheme,
    ModalOverlay: overlayTheme
  };
}
var themes = _object_spread_props(_object_spread({}, allThemes), {
  // bring back the full type, the rest use a subset to avoid clogging up ts,
  // tamagui will be smart and use the top level themes as the type for useTheme() etc
  light: createTheme(palettes.light, lightTemplate, {
    nonInheritedValues: lightColors
  }),
  dark: createTheme(palettes.dark, darkTemplate, {
    nonInheritedValues: darkColors
  })
});
export {
  themes
};
//# sourceMappingURL=themes-old.js.map
